
![image](https://user-images.githubusercontent.com/104200268/227314831-742e8f9e-8c0d-4339-8d30-1f48b045204b.png)
<p align="center"><i>Kingdom of Math</i> is a serious game that combines the addictive and engaging gameplay of an action RPG with optional but rewarding mathematical content. In a fantasy world, players can explore, fight enemies, learn skills, complete quests, find chests, collect and upgrade items. The game includes mathematical content in the form of shops, quests where players face real-world problems, riddles to open chests, and equations to upgrade items. By applying proven design principles for serious games, <i>Kingdom of Math</i>  provides an intrinsically motivating gameplay experience that aims to increase player engagement with mathematical topics.</p>

<br>

<div align="center">
 
`Unity`
`C#`
`Krita`
`Rider`
`Mixamo`
`Plastic SCM`

</div>

---

<p>
<img align="left" width="53%" height="auto" src="https://user-images.githubusercontent.com/104200268/227624597-b379a28d-b547-41ef-bdc3-bba323bf3e7f.gif">
<h1>About</h1>
<li><b>Role:</b>&emsp;&emsp;&emsp;&emsp;Solo Dev</li>
<li><b>Duration:</b>&emsp;&emsp;2 Months</li>
<li><b>Group Size:</b>&emsp;1</li>
<li><b>Engine:</b>&emsp;&emsp;&emsp;Unity</li>
<li><b>Genre:</b>&emsp;&emsp;&emsp;&nbsp;Action RPG x Serious Math Game</li>
<li><b>Platform:</b>&emsp;&emsp;PC</li>
<li><b>Context:</b>&emsp;&emsp;&nbsp;Bachelors’ Thesis</li>
<li><b>Build:</b>&emsp;&emsp;&emsp;&nbsp;&nbsp;<a href="https://lauramarsoner.itch.io/kingdomofmath">Itch.io</a></li>
</p>

<br>

<p>
<div>
<img align="right" width="42%" height="auto" src="https://user-images.githubusercontent.com/104200268/227627070-b529d4c9-8838-4a3e-8055-d579a45d0ede.png">
<br>
<h1>Responsibilities</h1>
<li><b>Gameplay Programming</b> (Combat, Inventory, Movement)</li>
<li><b>Game Design</b> (Level, Tutorial, Worldbuilding, Quests, UI/UX)</li>
<li><b>Tool Development</b> (Dialogue Editor, Configuration Options)</li>
<li><b>Combat System</b> (Weapons, Abilities, Animations, VFX)</li>
<li><b>Enemie-AI & NPC-AI</b></li>
<li><b>Dialogue, Quest & Shop System</b></li>
<li><b>Saving System, Scene Management</b></li>
<li><b>Progression System</b> (Stats, Traits, Difficulty)</li>
<li><b>Project Management & Source Control</b></li>
<li><b>Prototyping & Bugfixing</b></li>
<br>
<br>
</div>
</p>


<br>

<p>
<div>
<img align="left" width="50%" height="auto" src="https://user-images.githubusercontent.com/104200268/227796152-a848cc4a-c7f6-4511-988b-5db69b7c1583.gif">
<br>
<h1>Features</h1>
<li>Items & Inventory</li>
<li>Combat & Abilities</li>
<li>Stats & Traits</li>
<li>Dialogues & Quests</li>
<li>Different Enemies</li>
<li>Tutorial + Prototype Level (1h - 1.5h playtime)</li>
<li>Math Content (Quests, Chests, Shops, Item Upgrades)</li>
</div>
</p>

<br>

---


 <a href="http://www.youtube.com/watch?feature=player_embedded&v=zHgLsDbrP3M
" target="_blank"><img src="https://user-images.githubusercontent.com/104200268/227638337-fd73fd4e-50a8-41b3-9bd4-4d418f4fe416.png" 
alt="Watch Trailer on YouTube" align="right" width="60%" height="auto" border="10" /></a>
<br>
 <br>
  <br>
<div align="center"> Klick on the Image on the right or the button below to watch the Trailer on YouTube! 
<br>
<br>

 
[![Watch Trailer on YouTube](https://img.shields.io/badge/Watch%20Trailer-FF0000?logo=youtube&style=for-the-badge)](http://www.youtube.com/watch?feature=player_embedded&v=zHgLsDbrP3M) 

</div>

<br>
<br>


---

<p>
<h1>Additional Information</h1>
<details>

  <summary>Dialogues & Dialogue Editor</summary>
 
 
  > <details> 
  >  <summary>Dialogues</summary>
  >  <br>
  >  <div align="center">
  >    The players can interact with NPCs by clicking on them, which opens the dialogue window. The conversation starts with the NPC's part, followed by the player's response with multiple answer choices. The dialogues can trigger NPC actions, such as giving quests and NPCs can give random answers. 
  >    Dialogues should enhance immersion while adding a dynamic feeling to the game.
  >   <img src="https://user-images.githubusercontent.com/104200268/227634579-c074e1ef-75a3-4509-9fca-d6fabc0073be.gif" width="60%" height="auto">
  >   </div>
  >  </details>
  
 > <details> 
 >   <summary>Dialogue Editor</summary>
 >
 >   <br>
 >
 >    <div align="center">
 >    The Dialogue Editor also allows developers to create dialogs quickly and efficiently and provides a better overview over the dialogue. Each dialogue consists of several nodes that are connected by Bézier curves.     
 >     <img src="https://user-images.githubusercontent.com/104200268/227770424-3d76d338-f03b-4df5-a914-addf655d198a.png" width="80%" height="auto">
 >     </div>
 >
 >    <br>
 >
 >    <div align="center"> 
 >    Nodes can be added, linked, or deleted, and can also be moved and arranged by dragging them.
 >    <img src="https://user-images.githubusercontent.com/104200268/227791963-3c6d6053-8d6b-49de-ae02-3e3182ebc0c5.gif" width="80%" height="auto">
 >    </div>
 >
 >    <br>
 >
 >    <div align="center">
 >    The Nodes are implemented using scriptable objects. There are different configuration options for the nodes: the size of the text field, selecting whether it is a player or NPC part of the conversation, and adding an Enter or Exit actions. Conditions can be set, such as requiring players to have certain items in their inventory to unlock specific answer options, which is useful for quests and gameplay.
 >    <img src="https://user-images.githubusercontent.com/104200268/227792229-3e894d1e-12cc-48b5-a301-15247fc87b24.png" width="50%" height="auto">
 >      
 >    Triggers can be used to activate actions when a dialog node is entered or exited, such as removing quest items from the player's inventory or giving rewards. The combination of conditions and triggers in dialogs is a powerful tool for driving the story and gameplay. 
 > </div>
 >   
 > <br>
 >
 > </details>
 
 > <details> 
 >  <summary>Code Snippets</summary>
 >  <br>
 >    Creation of an Editor Window
 >
 > ```c#
 > [MenuItem("Window/Dialogue Editor")]
 > public static void ShowEditorWindow()
 > {
 >     GetWindow(typeof(DialogueEditor), false, "Dialogue Editor");
 > }
 > ```
 > <br>
 >    This Method draws the Bezier Curves to connect the dialogue nodes.
 >
 > ```csharp
 > private void DrawConnections(DialogueNode node)
 > {
 >     Vector3 startPosition = new Vector3(node.GetRect().xMax, node.GetRect().center.y,0);
 >     foreach (DialogueNode childNode in _selectedDialogue.GetAllChildren(node))
 >     {
 >         Vector3 endPosition = new Vector3(childNode.GetRect().xMin, childNode.GetRect().center.y,0);
 >         Vector3 controlPointOffset = endPosition - startPosition;
 >         controlPointOffset.y = 0;
 >         controlPointOffset.x *= 0.9f;
 >         Handles.DrawBezier(startPosition, endPosition, startPosition + controlPointOffset, 
 >           endPosition - controlPointOffset, Color.white, null, 4f);
 >     }
 > }
 > ```
 > <br>
 >    This Method is called if a Dialogue Scriptable object is opened and automatically opens the Dialogue Editor.
 >
 > ```csharp
 > [OnOpenAsset(1)]
 > public static bool OpenDialogue(int instanceID, int line)
 > {
 >     Dialogue dialogue = EditorUtility.InstanceIDToObject(instanceID) as Dialogue;  
 >     if (dialogue != null)
 >     {
 >         ShowEditorWindow();
 >         _selectedDialogue = dialogue;
 >         return true;
 >     }
 >     return false;
 > }
 > ```
 ><br>
 >
 >    This Code only works in the Editor Mode and displays how nodes are created and deleted.
 >
 > ```csharp
 > #if UNITY_EDITOR
 >   public void CreateNode(DialogueNode parent)
 >   {
 >       DialogueNode child = MakeNode(parent);
 >       Undo.RegisterCreatedObjectUndo(child, "Created Dialogue Node");
 >       if (AssetDatabase.GetAssetPath(this) != "")
 >       {
 >           Undo.RecordObject(this, "Added Dialogue Node");
 >       }       
 >       AddNode(child);
 >   }
 >       
 >   public void DeleteNode(DialogueNode nodeToDelete)
 >   {
 >       Undo.RecordObject(this, "Removed Dialogue Node");
 >       nodes.Remove(nodeToDelete);
 >       CleanDeletedChildren(nodeToDelete);
 >       OnValidate();
 >       Undo.DestroyObjectImmediate(nodeToDelete);
 >   }
 >
 >   private DialogueNode MakeNode(DialogueNode parent)
 >   {
 >       DialogueNode child = CreateInstance<DialogueNode>();
 >       child.name = Guid.NewGuid().ToString();
 >       if (parent != null)
 >       {
 >           parent.AddChild(child.name);
 >           child.SetPlayerSpeaking(!parent.IsPlayerSpeaking());
 >           child.SetPosition(parent.GetRect().position + newNodeOffset);
 >       }
 >       return child;
 >   }
 >
 >   private void AddNode(DialogueNode child)
 >   {
 >       nodes.Add(child);
 >       OnValidate();
 >   }
 >       
 >   private void CleanDeletedChildren(DialogueNode nodeToDelete)
 >   {
 >       foreach (DialogueNode node in GetAllNodes())
 >       {
 >           node.RemoveChild(nodeToDelete.name);
 >       }
 >   }
 > #endif
 > ```
 >
 > </details>

</details>

<details>
  <summary>Saving System</summary>
 <br>
 
 > <div align="center"> 
 >  If the player saves the game, the entire game state is saved, including dropped items, shops, chests, current health, mana, positions, money, inventory and equipment, dead enemies/players, experience, stats, traits, etc. The game is also automatically saved when a new level or scene is loaded. For this, persistent objects which persist between scenes are used as an alternative to the singleton pattern. The saving system is implemented by using unique IDs for each object to be saved, collecting all these objects, and saving them using JSON.
 > </div>
 
 > <details> 
 >  <summary>Code Snippets</summary>
 >  <br>
 >  Every object that has components that want to be saved needs to have a <code>JsonSaveableEntity.cs</code> script on it to allow the components to be saved. The following code displays how each object is assigned a unique identifier and how the saveable components of the object are saved and restored.
 >
 > ```csharp
 > [ExecuteAlways]
 > public class JsonSaveableEntity : MonoBehaviour
 > {
 >     [SerializeField] private string uniqueIdentifier = "";
 >      static Dictionary<string, JsonSaveableEntity> globalLookup = new Dictionary<string, JsonSaveableEntity>();
 > //Assigns a unique identifier to the object
 > #if UNITY_EDITOR
 >     private void Update() {
 >         if (Application.IsPlaying(gameObject)) return;
 >         if (string.IsNullOrEmpty(gameObject.scene.path)) return;
 >
 >         SerializedObject serializedObject = new SerializedObject(this);
 >         SerializedProperty property = serializedObject.FindProperty("uniqueIdentifier");
 >           
 >         if (string.IsNullOrEmpty(property.stringValue) || !IsUnique(property.stringValue))
 >         {
 >             property.stringValue = System.Guid.NewGuid().ToString();
 >             serializedObject.ApplyModifiedProperties();
 >         }
 >
 >         globalLookup[property.stringValue] = this;
 >     }
 > #endif
 >
 >     //Collects all saveable components of this object
 >     public JToken CaptureAsJtoken()
 >     {
 >         IDictionary<string, JToken> stateDict = state;
 >         foreach (IJsonSaveable jsonSaveable in GetComponents<IJsonSaveable>())
 >         {             
 >             JToken token = jsonSaveable.CaptureAsJToken();
 >             string component = jsonSaveable.GetType().ToString();
 >             stateDict[jsonSaveable.GetType().ToString()] = token;
 >         }
 >         return state;
 >     }
 >
 >     //Restores all saveable components of this object
 >     public void RestoreFromJToken(JToken s) 
 >     {
 >         JObject state = s.ToObject<JObject>();
 >         IDictionary<string, JToken> stateDict = state;
 >         foreach (IJsonSaveable jsonSaveable in GetComponents<IJsonSaveable>())
 >         {
 >             string component = jsonSaveable.GetType().ToString();
 >             if (stateDict.ContainsKey(component))
 >             {
 >                 jsonSaveable.RestoreFromJToken(stateDict[component]);
 >             }
 >         }
 >     }
 > }
 > ```
 > <br>
 > The <code>JsonSavingSystem</code> class contains the code for saving and loading Scenes and for deleting saveFiles.
 >
 > ```csharp
 > //Loads the last active Scene for example if the player wants to continue a game.
 > public IEnumerator LoadLastScene(string saveFile)
 > {
 >     JObject state = LoadJsonFromFile(saveFile);
 >     IDictionary<string, JToken> stateDict = state; 
 >     int buildIndex = SceneManager.GetActiveScene().buildIndex;
 >     if (stateDict.ContainsKey("lastSceneBuildIndex"))
 >     {
 >         buildIndex = (int)stateDict["lastSceneBuildIndex"];
 >     }
 >     yield return SceneManager.LoadSceneAsync(buildIndex);
 >     RestoreFromToken(state);
 > }
 >
 > //Loads a given savefile
 > public void Load(string saveFile)
 > {
 >     print("Loading from " + GetPathFromSaveFile(saveFile));
 >     RestoreFromToken(LoadJsonFromFile(saveFile));
 > }
 >
 >//Saves the state of the current scene to the savefile
 > public void Save(string saveFile)
 > {
 >     print("Saving to " + GetPathFromSaveFile(saveFile));
 >     JObject state = LoadJsonFromFile(saveFile);
 >     SaveFileAsJSon(saveFile, state);
 > }
 >
 > //Loads the json data from a file
 > private JObject LoadJsonFromFile(string saveFile)
 > {
 >     string path = GetPathFromSaveFile(saveFile);
 >     print("Loading from " + path);
 >     if (!File.Exists(path))
 >     {
 >         return new JObject();
 >     }
 >     using (var textReader = File.OpenText(path))
 >     {
 >         using (var reader = new JsonTextReader(textReader))
 >         {
 >             reader.FloatParseHandling = FloatParseHandling.Double;
 >             return JObject.Load(reader);
 >         }
 >     }
 > }
 >
 > //Saves the current state to a given savefile
 > private void SaveFileAsJSon(string saveFile, JObject state)
 > {
 >     string path = GetPathFromSaveFile(saveFile);
 >     print("Saving to " + path);
 >     using (var textWriter = File.CreateText(path))
 >     {
 >         using (var writer = new JsonTextWriter(textWriter))
 >         {
 >             writer.Formatting = Formatting.Indented;
 >             state.WriteTo(writer);
 >         }
 >     }
 > }
 >
 > //Deletes the given savefile
 > public void Delete(string saveFile)
 > {
 >     print("Deleting from " + GetPathFromSaveFile(saveFile));
 >     File.Delete(GetPathFromSaveFile(saveFile));
 > }
 >
 > //Collects all saveable objects in a dictionary and sets the lastSceneBuildIndex to the current scene
 > private void CaptureAsToken(JObject state)
 > {
 >     IDictionary<string, JToken> stateDict = state;
 >     foreach (JsonSaveableEntity saveable in FindObjectsOfType<JsonSaveableEntity>())
 >     {
 >         stateDict[saveable.GetUniqueIdentifier()] = saveable.CaptureAsJtoken();
 >     }
 >     stateDict["lastSceneBuildIndex"] = SceneManager.GetActiveScene().buildIndex;
 > }
 >
 > //Restores the state of all the saveable components 
 > private void RestoreFromToken(JObject state)
 > {
 >     IDictionary<string, JToken> stateDict = state;
 >     foreach (JsonSaveableEntity savable in FindObjectsOfType<JsonSaveableEntity>())
 >     {
 >         string id = savable.GetUniqueIdentifier();
 >         if (stateDict.ContainsKey(id))
 >         {
 >             savable.RestoreFromJToken(stateDict[id]);
 >         }
 >     }
 > }
 > ```
 > <br>
 > This is an example how the Saving of the Health of Players and Enemies works. The <code>_healthPoints</code> value is saved using <code>CaptureAsJToken()</code> and loaded using <code>RestoreFromJToken()</code>. After loading the state of the Characters is also updated using <code>UpdateState()</code>.
 >
 > ```csharp
 > public class Health : MonoBehaviour, IJsonSaveable
 > {
 >     private LazyValue<float> _healthPoints; //lazyvalue ensures that variable is initialized before use
 >     
 >     //Converts the healthPoints value to a JToken and returns it to be saved
 >     public JToken CaptureAsJToken()
 >     {
 >         return JToken.FromObject(_healthPoints.value);
 >     }
 >     
 >     //Restores the healthPoints from the given JToken and updates the state
 >     public void RestoreFromJToken(JToken state)
 >     {
 >         float val = state.ToObject<float>();
 >         _healthPoints.value = val;
 >         UpdateState();
 >     }
 >
 >     //Updates the state of the object having the health script on it
 >     private void UpdateState()
 >     {
 >         if (!_wasDeadLastFrame && IsDead())
 >         {
 >             _animator.SetTrigger(DieTrigger);
 >             _actionScheduler.CancelCurrentAction();
 >         }
 >         if (_wasDeadLastFrame && !IsDead())
 >         {
 >             _animator.Rebind();
 >         }
 >         _wasDeadLastFrame = IsDead();
 > }
 > ```
 >
 > </details>
</details>

<details>
  <summary>Scene Management</summary>
 <br>
 
 > <div align="center"> 
 > Portals are used for the transition between levels, through which the players can pass. As a transition, a white screen is displayed to provide enough time for the new scene to load, and then that scene is displayed. The players have set spawn points and are then spawned at that point and the corresponding level is loaded.
 > <img src="https://user-images.githubusercontent.com/104200268/227891326-1d00fcc3-2789-4860-9cef-499e59f94d5b.gif" width="80%" height="auto">
 > </div>
  <br>

 > <details> 
 >  <summary>Code Snippets</summary>
 >  <br>
 > After the player enters a portal the transition to the next scene is started.
 >
 > ```csharp
 > private void OnTriggerEnter(Collider other)
 > {
 >     if (other.CompareTag("Player"))
 >     {
 >         StartCoroutine(TransitionToScene());
 >     }
 > }
 > ```
 >
 > To transition to a new scene the playerController is disabled and the scene is faded out. Next the state of the current scene is saved, the next scene is loaded. Then the portal of the new scene where the player enters is loaded and the player is updated. The transition ends with saving the new scene, fading in and enabling player controls.
 >
 > ```csharp
 > private IEnumerator TransitionToScene()
 > {
 >     if (sceneToLoadIndex < 0)
 >     {
 >         Debug.LogError("Scene to load not set.");
 >         yield break; 
 >     }
 >           
 >     DontDestroyOnLoad(gameObject);
 >          
 >     Fader fader = FindObjectOfType<Fader>();
 >     SavingWrapper savingWrapper = FindObjectOfType<SavingWrapper>();
 >
 >     PlayerController playerController = GameObject.FindWithTag("Player").GetComponent<PlayerController>();
 >     playerController.enabled = false;
 >         
 >     yield return fader.FadeOut(fadeOutTime);
 >           
 >     savingWrapper.Save();
 >           
 >     yield return SceneManager.LoadSceneAsync(sceneToLoadIndex);
 >     PlayerController newPlayerController = GameObject.FindWithTag("Player").GetComponent<PlayerController>();
 >     newPlayerController.enabled = false;
 >           
 >     savingWrapper.Load();
 > 
 >     Portal otherPortal = GetOtherPortal();
 >     UpdatePlayer(otherPortal);
 >
 >     savingWrapper.Save();
 >           
 >     yield return new WaitForSeconds(fadeWaitTime);
 >           
 >     fader.FadeIn(fadeInTime);
 >           
 >     newPlayerController.enabled = true;
 >           
 >     Destroy(gameObject);
 > }
 >
 > //Updates the players position/rotation based on the new portal
 > private void UpdatePlayer(Portal otherPortal)
 > {
 >     GameObject player = GameObject.FindWithTag("Player");
 >     player.GetComponent<NavMeshAgent>().enabled = false;
 >     player.GetComponent<NavMeshAgent>().Warp(otherPortal.spawnPoint.position);
 >     player.transform.rotation = otherPortal.spawnPoint.rotation;
 >     player.GetComponent<NavMeshAgent>().enabled = true;
 > }
 > ```
 >
 > To fade in and out between scenes coroutines are use as displayed in the following code of the Fader.cs class.
 >
 > ```csharp 
 > public class Fader : MonoBehaviour
 > {
 >     private CanvasGroup _canvasGroup;
 >     private Coroutine currentActiveFade = null;
 > 
 >     private void Awake()
 >     {
 >         _canvasGroup = GetComponent<CanvasGroup>();
 >     }
 >
 >     public Coroutine FadeOut(float time)
 >     {
 >         return Fade(time, 1f);
 >     }
 >
 >     public Coroutine FadeIn(float time)
 >     {
 >         return Fade(time, 0);
 >     }
 >
 >     //Fades in or out depending on the alpha value
 >     public Coroutine Fade(float time, float alphaTarget)
 >     {
 >         if (currentActiveFade != null)
 >         {
 >             StopCoroutine(currentActiveFade);
 >         }
 >         currentActiveFade = StartCoroutine(FadeRoutine(time,alphaTarget));
 >         return currentActiveFade;
 >     }
 >     
 >     //Fades out immediately by setting the alpha of the canvasGroup to 1
 >     public void FadeOutImmediate()
 >     {
 >         _canvasGroup.alpha = 1;
 >     }
 >
 >     //Slowly increses/decreases the alpha value of the canvas until the intended alpha value is reached
 >     private IEnumerator FadeRoutine(float time, float alphaTarget)
 >     {
 >         while (!Mathf.Approximately(_canvasGroup.alpha,alphaTarget))
 >         {
 >             _canvasGroup.alpha = Mathf.MoveTowards(_canvasGroup.alpha,alphaTarget, Time.unscaledDeltaTime / time);
 >             yield return null; //wait for 1 frame
 >         }
 >     }
 > }
 > ```
 > <br>
 > </details>
   

</details> 
 
<details>
  <summary>Chests</summary>
  <br>
 
 > <div align="center"> 
 > Chests, as the name suggests, are objects placed in the world that contain items and work as follows. When the players hold the mouse cursor over a chest, the mouse cursor turns into a yellow square. When the players click on a chest, they automatically move into range of the chest, if they are not already in that range from where they can open it.
 > <br>
 > <img src="https://user-images.githubusercontent.com/104200268/227770156-dcc77aea-e740-4666-8390-46ec6a41f624.gif" width="80%" height="auto">
 > </div>
 > <br>
 > <div align="center"> 
 > Once the players are within range, the chest window displayed below opens. The window consists of a mathematical question, an answer field where the players can enter their answer, and a confirmation button. If the answer is correct, the chest opens and a pickup for an item is spawned.  
 > <img src="https://user-images.githubusercontent.com/104200268/227773074-8da5f304-e6e1-4149-80c5-539b9f4ffaaf.png" width="70%" height="auto">
 > </div>
 > <br>
 > <div align="center"> 
 > There are three different types of chests: easy chests, which are wooden and can be opened by solving easy math problems or even trick questions; medium chests, which are golden and can be opened by solving medium math problems; and difficult chests, which are purple and have a golden frame and can be opened by solving difficult math problems.
 > <br>
 > <img src="https://user-images.githubusercontent.com/104200268/227770154-8badb528-65da-446a-9569-44b6c27e9f2d.png" width="60%" height="auto">
 > </div>
 > <br>
 > <div align="center"> 
 > The chests are implemented using scriptable objects, where the developer can configure various options. This includes the respective math problem, a chest prefab depending on the difficulty, a chest protector being the fairy with the clues, a voice output for opening the chest, a level, and a drop library containing the loot that is spawned when the chest is opened.
 > <br>
 > <img src="https://user-images.githubusercontent.com/104200268/227963447-784f63a2-dc0a-4b69-b179-5859e7be0717.png" width="70%" height="auto">
 > </div>
 > <br>
 > <div align="center"> 
 > The math problems are also implemented using scriptable objects consisting of the difficulty, a question, a solution, and a list of hints.
 > <br>
 > <img src="https://user-images.githubusercontent.com/104200268/227963440-7fca7c13-5cd7-4499-abdd-c4c1eb7a5585.png" width="70%" height="auto">
 > </div> 
 <br>
</details>

<details>
  <summary>Shops</summary>
   <br>
   
   > <div align="center"> 
   >   Shops subtly teach math by motivating the players to buy and sell items at different prices and with or without discounts. A shop is indicated in the game by an NPC called a shopkeeper. The shop window shown below opens when clicking on a shopkeeper.
   >  <br>
   >  <img src="https://user-images.githubusercontent.com/104200268/227770460-569c4c95-b963-4cb7-a131-89b8d7e1130e.png" width="70%" height="auto">
   > </div> 
   > <br>
   > <div align="center"> 
   >  It contains various items available for purchase at the current player level, the quantity available for each, the price, and the number that will be added to the shopping list. The players can also switch between buying and selling and filter the items. If they have enough money to buy the corresponding items the items will be added to the players' inventory. 
   >  It should be noted that the transaction is completed only when there is enough space in the inventory and that the stackable items are stacked and not placed in separate places. If the players do not have enough money, the total amount will be displayed in red and the [Kaufen] button will be disabled. 
   >  <br>
   > <img src="https://user-images.githubusercontent.com/104200268/227770519-99289146-2117-4316-bfc8-f4d785567e80.gif" width="90%" height="auto">
   > <img src="https://user-images.githubusercontent.com/104200268/227770826-a3e598af-7dfa-428b-95e4-d6a2278be8af.gif" width="40%" height="auto">
   > </div> 
   > <br>
   > <div align="center"> 
   > There exist different types of shops for example, an armor shop sells different armor items. Some of these shops can also be seen in the image below, where a weapons shop can be seen on the left and an armor shop on the right.
   > <br>
   > <img src="https://user-images.githubusercontent.com/104200268/227770464-ebbb5689-2909-4237-acb7-b239e64786f8.png" width="70%" height="auto">
   > </div> 
   > <br>
   > <div align="center"> 
   > There are various configuration options for shops: the name of the shop, the stock is set by adding items to the stock list and configuring them. Therefore, the initial stock of an item and the level at which the item is sold in the shop can be set. This is used to replenish the shop when a player reaches a new level. Also, the default discount for an item and the sell percentage at which the item can be sold back to the shop can be set. Furthermore, a default selling percentage can be set for the whole shop, which is the percentage of money that the players will receive less for each item that they sell in that shop. Also the maximum discount that players can get in this shop if they maximize the Charisma trait, can be set.
   > <br>
   > <img src="https://user-images.githubusercontent.com/104200268/227975579-137436f0-f745-41a3-8981-af81d934cb19.PNG" width="70%" height="auto">
   > </div>
   <br>
</details>

<details>
  <summary>Item Upgrades</summary>
   <br>
   
   > <div align="center"> 
   > Mathematical content is also integrated into the game through item upgrades. Players can increase a stat corresponding to the item they are upgrading by assigning numbers and signs to different slots to form an equation that gets as close as possible to the maximum number, without exceeding it. This should motivate players to practice mental arithmetic and provides them with the opportunity to optimize their equations each time they collect a new number or sign.
   > <br>
   > <img src="https://user-images.githubusercontent.com/104200268/227770235-918c6946-e085-44bb-8934-d9b8539eb122.gif" width="100%" height="auto">
   > </div>
   > <br>
   > <div align="center"> 
   > Players can move numbers between different items to maximize their stats. The reached value is automatically updated and added to the respective stat. The numbers and signs can be changed at any time to optimize the stat of the item. Only simple operations like addition, subtraction, multiplication, and division are currently supported.
   > <br>
   > <img src="https://user-images.githubusercontent.com/104200268/227773157-4fd39c2a-9f3e-492e-a889-8a4d9cde515f.png" width="50%" height="auto">
   > </div>
   > <br>
</details>

<details>
 <summary>Quests</summary>
  <br>
 
  > <div align="center"> 
  > The game features various levels, each focused on a different topic such as percentage calculations, and includes quests that present real-world problems related to the topic. The quests are designed to engage players emotionally by creating an attachment to NPC characters and motivating them to solve mathematical problems to help those characters.
  > The game also includes a quest window displaying active and completed quests, along with their goals and rewards.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227773129-757250c6-f349-4574-a258-8c4c31d723f8.png" width="80%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  > Quests are implemented using scriptable objects that contain objectives, descriptions, and conditions for completion.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227784059-d7468f50-ab60-453d-9dc0-a67f2a4eeebe.PNG" width="70%" height="auto">
  > </div>
  > <br> 
 </details>

<details>
  <summary>NPCs</summary>
    <br>
  
  > <div align="center"> 
  > Non-playable characters (NPCs) play a crucial role in a game's story, gameplay, and immersion. There are two types of NPCs: static NPCs and those with dialogs or quests for players. 
  > <img src="https://user-images.githubusercontent.com/104200268/228180590-fa9d8973-d424-455f-aba7-bfbc68b266ae.png" width="80%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  > Static NPCs help make the game world feel more lively, while those with quests or dialogs allow players to interact with them and advance the game's story.  
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/228180616-3b94ff96-29eb-4d8c-ac92-5ff912173a2f.png" width="80%" height="auto">
  > </div>
  > <br>
  > <div align="center">     
  > To implement NPCs, an NPC Controller is used, which contains a list of NPCActions. Each NPCAction includes a description, position in the game world, time for the action, speed, dialog, and list of animation states. The NPC begins in the first action and moves at the set speed to the next action's position when the specified time has elapsed or when a dialog trigger changes the action. 
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/228182600-d797f8b2-2c40-41ab-a73c-17a17bbceab7.PNG" width="70%" height="auto">
  > </div>
  > <br>
  > <div align="center">
  > The use of dialogue triggers provides a high level of control over the NPC's behavior, allowing for multiple actions and dialogues for a single NPC to enhance the game's realism. Also The NPCs gan give quests, complete quest or give the players items.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227784080-f1cc0818-f074-486c-a6da-b61cf8b560dc.PNG" width="70%" height="auto">
  > </div>
 <br>

</details>

<details>
  <summary>Enemies</summary>
  <br>
 
 > <div align="center"> 
  > An enemy is a character similar to the NPC, but with the difference that players can fight against it. In this game, there are different classes of enemies such as unarmed, soldiers, and archers, depending on the fighting style. This class also determines the basic stats of the enemy. There are also different enemy types such as skeletons, goblins, and guards, which currently only determine the appearance of the enemies, but not their stats.
  > <img src="https://user-images.githubusercontent.com/104200268/227770721-d5af6a25-117b-4bcf-bbc9-f14638d5cdc3.PNG" width="80%" height="auto">
  > </div>
  > <br>
 > <div align="center"> 
  > Each enemy has its own base stats, a droptable and an AIController. There are various configuration options, such as chase distance, suspicion time, patrol path, aggro cooldown, and shout distance, which allow for dynamic behavior. Additionally, aggro groups can be defined to make nearby enemies attack when one is attacked. These features allow developers to easily create a large set of enemies with different behavior, making the game feel more natural.
 > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227782446-ce732ad7-9e89-4f33-bd9d-aa1a6d338b1c.PNG" width="70%" height="auto">
  > </div>
> <br>
 
</details>
 
<details>
  <summary>Combat</summary>
  <br>
 
  > <div align="center"> 
  >  When the players hover over a potential enemy, the cursor turns into a sword if they can fight it. After that, the players automatically attack until the enemy is dead, and move to the next enemy, which is randomly selected from the attacking enemies. The automatic attack was implemented to make combat a bit easier, as the controls and camera are difficult to control at first, and the colliders of the enemies are quite small, so the players may click out of place, which can be frustrating. However, the players can also switch between enemies and run away by themselves and do not have to use automatic attacks, as they only serve as an aid
  > <img src="https://user-images.githubusercontent.com/104200268/227770574-cb417695-9541-4a4f-8e6f-ce76981e2da6.gif" width="80%" height="auto">
  > </div>
  > <br>
   > <div align="center"> 
  > When an opponent or the player is hit, the damage value is displayed above the head of the respective character. After the player's first attack, the enemy's life bar is also displayed. This was implemented so that the world still looks immersive and players cannot see the enemies' life bars from afar and find them easily.
  > <img src="https://user-images.githubusercontent.com/104200268/227770300-7b7ad007-3772-4824-a9cb-df7fcbc2a674.png" width="50%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  >  When an enemy dies, the loot is spawned according to the respective drop table and the enemy will remain dead. If the players die, they will respawn at a set respawn point in the level with 70 percent health, and the enemies they fought will also regenerate up to 70 percent health and will move back to their starting position over time. The players also do not lose loot when they die, as not to punish them for it. Also, different sounds are played for the different character classes when they get hit or die, along with corresponding animations.
  > <img src="https://user-images.githubusercontent.com/104200268/227770600-8bd23f67-29e6-4a71-b5c4-b9e46901845b.gif" width="80%" height="auto">
  > </div>
  > <br>
 
</details>
 
<details>
  <summary>Abilities</summary>
  <br>
    
  > <div align="center"> 
  > Abilities are a key aspect of combat in the game, providing players with an additional attack option alongside normal attacks. Abilities can be activated by pressing the appropriate key, with some taking effect immediately, such as health potions, while others require the player to click on the ground where they want the ability to be cast. Abilities have mana costs and cooldowns, and consumables are removed from the inventory when used up.
  > <img src="https://user-images.githubusercontent.com/104200268/227770296-7393e827-009d-40d3-8bf2-66c58208fe2a.png" width="50%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  >  These abilities can be equipped in the action bar, with the first four slots reserved for abilities and the last two for consumables like health potions.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227773065-0ac0cdaf-2a90-47f8-b20a-23169dcc175b.png" width="60%" height="auto">
  > </div>
  > <br>
  
  > <div align="center"> 
  > Abilities are implemented as scriptable objects with configuration options such as being consumable, equipment slot, cooldown, and mana cost. A targeting strategy, filtering strategy, and effect strategy must also be defined. The targeting strategy can be self-targeting, multiple-targeting, single-targeting, or directional-targeting. The filtering strategy specifies which characters to target and how to filter them. After setting the target, effects such as animations and particle effects are executed in the specified order.
  > <img src="https://user-images.githubusercontent.com/104200268/227782438-9990bba2-73d9-488f-89f5-8ca20afa2ae3.PNG" width="70%" height="auto">
  > </div>
  > <br>
</details>
 


<details>
  <summary>Items, Inventory & Equipment</summary>
 <br>
  
  > <div align="center"> 
  > Items are an essential part of the RPG game and can be collected by players in the game world and added to their inventory. There exist different types of items, including equipment, consumables, abilities, weapons, numbers, signs, quests, currency, and experience items. Some items are stackable, while others require a separate slot in the inventory. Players can drop and remove items from the inventory and pick them up again by clicking on them in the game world.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227773165-9d35752c-2f08-4d92-ab82-c4e7d3b60c9c.png" width="50%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  >  When hovering over an item, a tooltip appears showing details about the item, such as its name and description.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227770376-1bd74a0c-e1eb-49fa-aa4f-ba115ed9c0a5.png" width="50%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  >  There exist different qualities of items. They range from common to legendary and have a corresponding pickup, as shown below, where white stands for common and orange for legendary. A pickup is an object that appears in the real world as a placeholder for the different items and can be collected by clicking on it to obtain the item. 
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227773612-9354560d-2631-44d9-bac0-9722b049a7f2.PNG" width="80%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  >  Equipment items are used to describe items that the players can equip in a separate equipment window, as shown below. They represent different armor types, including helmets, chests, gloves, boots, and shields. Each armor type can only be equipped in a specific slot, indicated by a grayed-out image. The items can be equipped by dragging them from the inventory to the corresponding slot in the equipment window. In addition, weapon items can also be equipped in the Equipment window, but they are a separate item type as they have extra configuration options.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227773632-13ac5757-80d4-482c-8c00-0a187c97fb62.png" width="50%" height="auto">
  > </div>
  > <br> 
  > <div align="center"> 
  > Items are implemented using scriptable objects, each of which has a name, a unique ID, a description, an icon, and a pickup. Also, for each item, its price in the store, its category, which is used to filter items in the store, whether it is stackable, its level and, if it has a bonus stat, what stat that is, its maximum value and its current value can be configured. In addition, there exist other configurations that depend on the type of item and are described in the corresponding section.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227782490-362ea03f-2107-456b-b195-65b74c05f1ae.PNG" width="70%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  > Weapons are an important item type and are categorized into three types: unarmed, sword, and bow. The weapons are implemented using scriptable objects, which allow for customization of their range, damage, animation, and appearance. The animations are controlled by an animator override controller to maintain correct animations when changing weapons during runtime. Additionally, hit points can be set in the animations for more realistic combat behavior.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227783402-ae62c1aa-3ba2-4de1-a588-ec69baa010b7.PNG" width="70%" height="auto">
  > </div>
  > <br>

</details>

<details>
  <summary>Stats & Traits</summary>
 <br>
  
  > <div align="center"> 
  > The game includes various stats such as Health, Damage, Mana, Defense, and Cooldown Reduction, among others. The player and enemies have base stats based on their level. Players can increase their stats by leveling up, assigning traits, and equipping or upgrading items. The players can view their stats by pressing the [S] key.
 > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227770405-c5de455d-2b22-4b6a-9718-c5bfed2134e6.png" width="50%" height="auto">
  > </div>
  > <br>  
  > <div align="center"> 
  >  The game also features a trait system where players can improve their stats without equipping items. Traits such as Charisma and Stamina increase specific stats by a set amount per trait point. The trait window can be opened with the [T] key, and players can assign trait points by clicking on the [+] next to the desired trait and confirming. Once a trait point is confirmed, it cannot be undone.
 > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227770407-1ae44eb7-fcd5-489c-94f2-1a1e2b7dbf7c.png" width="50%" height="auto">
  > </div>
  > <br>
  
</details>

<details>
  <summary>Menu</summary>
  <br>
 
  > <div align="center"> 
  > The game has a main menu where players can continue a game, create a new game with a name, open a saved game, play the tutorial, or quit the game.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227770545-a1086e54-4a32-4f67-aca6-2fe967083310.png" width="80%" height="auto">
  > </div>
  > <br>  
  > <div align="center"> 
  >  The settings menu allows players to configure sound and quality settings.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/228370299-11aee5eb-5d0a-4963-a0bb-0d6d80bdf896.PNG" width="50%" height="auto">
  > </div>
  > <br>  
  > <div align="center"> 
  > Players can create new games and name them.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/228370229-e0d6bd59-3068-4ddb-9f0d-486bceb5e15d.PNG" width="50%" height="auto">
  > </div>
  > <br>  
  > <div align="center"> 
  > It is also possible to have multiple games with different states and to load a previously saved game.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/228370253-86b38c17-2f6f-4566-9d82-d96892c1ed7b.PNG" width="50%" height="auto">
  > </div>
  > <br>  
  > <div align="center"> 
  >  The game can be paused with the [P] key, which freezes time and opens a pause menu where players can save the game and return to the main menu. 
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227770529-10d03e56-53cc-4d44-85d2-3c4264bc70d0.png" width="50%" height="auto">
  > </div>
  > <br>  
 
</details>
 
 <details>
  <summary>HUD</summary>
  <br>
  
  > <div align="center"> 
  >   The HUD is used to display various information to the players. It is static on the screen so that the information remains visible during the game. In this game, the HUD consists of the purse, which displays the player's current money in the lower left, the quest menu in the lower right, the action bar in the lower center, and the player status in the upper left. The player's status bar shows the player's icon, current and maximum Health, current and maximum Mana, and current level and the experience needed to level up.
 > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227770525-ef541b4f-d53b-4120-807c-01e16119342c.png" width="90%" height="auto">
  > </div>
  > <br>
  
</details>

 <details>
  <summary>Tutorial</summary>
  <br>
  
  > <div align="center"> 
  > The tutorial introduces various mechanics and features to players in a linear manner. It is implemented using an NPC that explains each feature to the players in a dialog and verifies their understanding through checkpoints. 
 > The tutorial in a game starts with the players interacting with an NPC, who explains the movement and camera controls, basic combat, and HUD. The players must then open a chest, collect an item, and equip it to fight an enemy blocking the way to the next tutorial level. To reach the second level, the players must collect items and pass through a portal, which is explained to them.
  > <img src="https://user-images.githubusercontent.com/104200268/227770307-db398f6f-c979-40eb-82f8-4371b3911c14.png" width="90%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  >  In the second part of the game tutorial, players are introduced to abilities and the action bar, followed by a combat sequence where they can test their new abilities. An item dropped by an enemy is used to explain the players' stats, and a chest is opened to show how items are enhanced by bonus stats. Quests are then introduced, where players must collect diamonds from enemies to deepen their understanding of combat mechanics and quests. Completing the quest levels up the player, and trait points are explained. Shops are then introduced, followed by a lesson on how to pause and save the game.
 > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227770308-6e6f8038-4a5b-4b0e-a55b-abe1af29667d.png" width="90%" height="auto">
  > </div>
  > <br>
</details>

<details>
  <summary>Level</summary>
 <br>
  
  > <div align="center"> 
  >  The first level of the game, includes a main quest line where players help a farmer chase dwarves away from his farm. To complete the quest, players must defeat enemies in the forest and ruins, talk to the dwarves, and retrieve ingredients to bake apple pie for them. There are also enemies to battle, chests hidden throughout the level that provide items to make combat easier, and shops where players can buy items to get stronger.
 > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227773147-16f01469-d92c-4dd5-acf4-150a542f906f.png" width="90%" height="auto">
  > </div>
  > <br>

</details>
 
 <details>
  <summary>Thesis</summary>
 <br>
  
  > <div align="center"> 
  >  If you are interested in obtaining more information, you can download the final presentation and the bachelor's thesis using the links provided below. These resources contain valuable insights and details about the project.
  > <br>
  > <br>
  >
  > [Presentation.pdf](https://github.com/MarsonerLaura/KingdomOfMath/files/11094274/BA.Prasentation.pptx.pdf)
  > <br>
  >
  > [Thesis.pdf](https://github.com/MarsonerLaura/KingdomOfMath/files/11094238/Thesis.pdf)
  > <br>
  > <br>
  > Abstract
  > <br>
  > Serious games have shown promise as a tool to enhance the learning experience by generating higher intrinsic motivation than traditional learning methods. In this paper, a serious game called Kingdom of Math is developed that aims to teach mathematics to secondary school students using proven design principles. To this end, essential terms and concepts are described, and related work is analyzed. The requirements for such a serious game are outlined, and the approach and design decisions made are discussed and implemented. A user study is conducted to evaluate the developed game, and the results are presented and discussed. In addition, possible improvements and enhancements for this project in the future are suggested.
  > </div>
  > <br>
> 
   

  


</details>
 
</p>
