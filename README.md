
![image](https://user-images.githubusercontent.com/104200268/227314831-742e8f9e-8c0d-4339-8d30-1f48b045204b.png)
<p align="center"><i>Kingdom of Math</i> is a serious game that combines the addictive and engaging gameplay of an action RPG with optional but rewarding mathematical content. In a fantasy world, players can explore, fight enemies, learn skills, complete quests, find chests, collect and upgrade items. The game includes mathematical content in the form of shops, quests where players face real-world problems, riddles to open chests, and equations to upgrade items. By applying proven design principles for serious games, <i>Kingdom of Math</i>  provides an intrinsically motivating gameplay experience that aims to increase player engagement with mathematical topics.</p>

<br>

<div align="center">
 
`Unity`
`C#`
`Krita`
`Rider`
`Mixamo`
`Google Sheets`

</div>

---

<p>
<img align="left" width="53%" height="auto" src="https://user-images.githubusercontent.com/104200268/227624597-b379a28d-b547-41ef-bdc3-bba323bf3e7f.gif">
<h1>About</h1>
<li><b>Role:</b>&emsp;&emsp;&emsp;&emsp;Solo Dev</li>
<li><b>Duration:</b>&emsp;&emsp;2 Months</li>
<li><b>Group Size:</b>&emsp;1</li>
<li><b>Engine:</b>&emsp;&emsp;&emsp;Unity</li>
<li><b>Genre:</b>&emsp;&emsp;&emsp;&nbsp;Action RPG x Serious Math Game</li>
<li><b>Platform:</b>&emsp;&emsp;PC</li>
<li><b>Context:</b>&emsp;&emsp;&nbsp;Bachelors’ Thesis</li>
<li><b>Build:</b>&emsp;&emsp;&emsp;&nbsp;&nbsp;<a href="https://lauramarsoner.itch.io/kingdomofmath">Itch.io</a></li>
</p>

<br>

<p>
<div>
<img align="right" width="42%" height="auto" src="https://user-images.githubusercontent.com/104200268/227627070-b529d4c9-8838-4a3e-8055-d579a45d0ede.png">
<br>
<h1>Responsibilities</h1>
<li><b>Gameplay Programming</b> (Combat, Inventory, Movement)</li>
<li><b>Game Design</b> (Level, Tutorial, Worldbuilding, Quests, UI/UX)</li>
<li><b>Tool Development</b> (Dialogue Editor, Configuration Options)</li>
<li><b>Combat System</b> (Weapons, Abilities, Animations, VFX)</li>
<li><b>Enemie-AI & NPC-AI</b></li>
<li><b>Dialogue, Quest & Shop System</b></li>
<li><b>Saving System, Scene Management</b></li>
<li><b>Progression System</b> (Stats, Traits, Difficulty)</li>
<li><b>Project Management & Source Control</b></li>
<li><b>Prototyping & Bugfixing</b></li>
<br>
<br>
</div>
</p>


<br>

<p>
<div>
<img align="left" width="50%" height="auto" src="https://user-images.githubusercontent.com/104200268/227796152-a848cc4a-c7f6-4511-988b-5db69b7c1583.gif">
<br>
<h1>Features</h1>
<li>Items & Inventory</li>
<li>Combat & Abilities</li>
<li>Stats & Traits</li>
<li>Dialogues & Quests</li>
<li>Different Enemies</li>
<li>Tutorial + Prototype Level (1h - 1.5h playtime)</li>
<li>Math Content (Quests, Chests, Shops, Item Upgrades)</li>
</div>
</p>

<br>

---


 <a href="http://www.youtube.com/watch?feature=player_embedded&v=zHgLsDbrP3M
" target="_blank"><img src="https://user-images.githubusercontent.com/104200268/227638337-fd73fd4e-50a8-41b3-9bd4-4d418f4fe416.png" 
alt="Watch Trailer on YouTube" align="right" width="60%" height="auto" border="10" /></a>
<br>
 <br>
  <br>
<div align="center"> Klick on the Image on the right or the button below to watch the Trailer on YouTube! 
<br>
<br>

 
[![Watch Trailer on YouTube](https://img.shields.io/badge/Watch%20Trailer-FF0000?logo=youtube&style=for-the-badge)](http://www.youtube.com/watch?feature=player_embedded&v=zHgLsDbrP3M) 

</div>

<br>
<br>


---

<p>
<h1>Additional Information</h1>
<details>

  <summary>Dialogues & Dialogue Editor</summary>
 
 
  > <details> 
  >  <summary>Dialogues</summary>
  >  <br>
  >  <div align="center">
  >    The players can interact with NPCs by clicking on them, which opens the dialogue window. The conversation starts with the NPC's part, followed by the player's response with multiple answer choices. The dialogues can trigger NPC actions, such as giving quests and NPCs can give random answers. 
  >    Dialogues should enhance immersion while adding a dynamic feeling to the game.
  >   <img src="https://user-images.githubusercontent.com/104200268/227634579-c074e1ef-75a3-4509-9fca-d6fabc0073be.gif" width="60%" height="auto">
  >   </div>
  >  </details>
  
 > <details> 
 >   <summary>Dialogue Editor</summary>
 >
 >   <br>
 >
 >    <div align="center">
 >    The Dialogue Editor also allows developers to create dialogs quickly and efficiently and provides a better overview over the dialogue. Each dialogue consists of several nodes that are connected by Bézier curves.     
 >     <img src="https://user-images.githubusercontent.com/104200268/227770424-3d76d338-f03b-4df5-a914-addf655d198a.png" width="80%" height="auto">
 >     </div>
 >
 >    <br>
 >
 >    <div align="center"> 
 >    Nodes can be added, linked, or deleted, and can also be moved and arranged by dragging them.
 >    <img src="https://user-images.githubusercontent.com/104200268/227791963-3c6d6053-8d6b-49de-ae02-3e3182ebc0c5.gif" width="80%" height="auto">
 >    </div>
 >
 >    <br>
 >
 >    <div align="center">
 >    The Nodes are implemented using scriptable objects. There are different configuration options for the nodes: the size of the text field, selecting whether it is a player or NPC part of the conversation, and adding an Enter or Exit actions. Conditions can be set, such as requiring players to have certain items in their inventory to unlock specific answer options, which is useful for quests and gameplay.
 >    <img src="https://user-images.githubusercontent.com/104200268/227792229-3e894d1e-12cc-48b5-a301-15247fc87b24.png" width="50%" height="auto">
 >      
 >    Triggers can be used to activate actions when a dialog node is entered or exited, such as removing quest items from the player's inventory or giving rewards. The combination of conditions and triggers in dialogs is a powerful tool for driving the story and gameplay. 
 > </div>
 >   
 > <br>
 >
 > </details>
 
 > <details> 
 >  <summary>Code Snippets</summary>
 >  <br>
 >    Creation of an Editor Window
 >
 > ```c#
 > [MenuItem("Window/Dialogue Editor")]
 > public static void ShowEditorWindow()
 > {
 >     GetWindow(typeof(DialogueEditor), false, "Dialogue Editor");
 > }
 > ```
 > <br>
 >    This Method draws the Bezier Curves to connect the dialogue nodes.
 >
 > ```csharp
 > private void DrawConnections(DialogueNode node)
 > {
 >     Vector3 startPosition = new Vector3(node.GetRect().xMax, node.GetRect().center.y,0);
 >     foreach (DialogueNode childNode in _selectedDialogue.GetAllChildren(node))
 >     {
 >         Vector3 endPosition = new Vector3(childNode.GetRect().xMin, childNode.GetRect().center.y,0);
 >         Vector3 controlPointOffset = endPosition - startPosition;
 >         controlPointOffset.y = 0;
 >         controlPointOffset.x *= 0.9f;
 >         Handles.DrawBezier(startPosition, endPosition, startPosition + controlPointOffset, 
 >           endPosition - controlPointOffset, Color.white, null, 4f);
 >     }
 > }
 > ```
 > <br>
 >    This Method is called if a Dialogue Scriptable object is opened and automatically opens the Dialogue Editor.
 >
 > ```csharp
 > [OnOpenAsset(1)]
 > public static bool OpenDialogue(int instanceID, int line)
 > {
 >     Dialogue dialogue = EditorUtility.InstanceIDToObject(instanceID) as Dialogue;  
 >     if (dialogue != null)
 >     {
 >         ShowEditorWindow();
 >         _selectedDialogue = dialogue;
 >         return true;
 >     }
 >     return false;
 > }
 > ```
 ><br>
 >
 >    This Code only works in the Editor Mode and displays how nodes are created and deleted.
 >
 > ```csharp
 > #if UNITY_EDITOR
 >   public void CreateNode(DialogueNode parent)
 >   {
 >       DialogueNode child = MakeNode(parent);
 >       Undo.RegisterCreatedObjectUndo(child, "Created Dialogue Node");
 >       if (AssetDatabase.GetAssetPath(this) != "")
 >       {
 >           Undo.RecordObject(this, "Added Dialogue Node");
 >       }       
 >       AddNode(child);
 >   }
 >       
 >   public void DeleteNode(DialogueNode nodeToDelete)
 >   {
 >       Undo.RecordObject(this, "Removed Dialogue Node");
 >       nodes.Remove(nodeToDelete);
 >       CleanDeletedChildren(nodeToDelete);
 >       OnValidate();
 >       Undo.DestroyObjectImmediate(nodeToDelete);
 >   }
 >
 >   private DialogueNode MakeNode(DialogueNode parent)
 >   {
 >       DialogueNode child = CreateInstance<DialogueNode>();
 >       child.name = Guid.NewGuid().ToString();
 >       if (parent != null)
 >       {
 >           parent.AddChild(child.name);
 >           child.SetPlayerSpeaking(!parent.IsPlayerSpeaking());
 >           child.SetPosition(parent.GetRect().position + newNodeOffset);
 >       }
 >       return child;
 >   }
 >
 >   private void AddNode(DialogueNode child)
 >   {
 >       nodes.Add(child);
 >       OnValidate();
 >   }
 >       
 >   private void CleanDeletedChildren(DialogueNode nodeToDelete)
 >   {
 >       foreach (DialogueNode node in GetAllNodes())
 >       {
 >           node.RemoveChild(nodeToDelete.name);
 >       }
 >   }
 > #endif
 > ```
 >
 > </details>

</details>

<details>
  <summary>Saving System</summary>
 <br>
 
 > <div align="center"> 
 >  If the player saves the game, the entire game state is saved, including dropped items, shops, chests, current health, mana, positions, money, inventory and equipment, dead enemies/players, experience, stats, traits, etc. The game is also automatically saved when a new level or scene is loaded. For this, persistent objects which persist between scenes are used as an alternative to the singleton pattern. The saving system is implemented by using unique IDs for each object to be saved, collecting all these objects, and saving them using JSON.
 > </div>
 
 > <details> 
 >  <summary>Code Snippets</summary>
 >  <br>
 >  Every object that has components that want to be saved needs to have a <code>JsonSaveableEntity.cs</code> script on it to allow the components to be saved. The following code displays how each object is assigned a unique identifier and how the saveable components of the object are saved and restored.
 >
 > ```csharp
 > [ExecuteAlways]
 > public class JsonSaveableEntity : MonoBehaviour
 > {
 >     [SerializeField] private string uniqueIdentifier = "";
 >      static Dictionary<string, JsonSaveableEntity> globalLookup = new Dictionary<string, JsonSaveableEntity>();
 > //Assigns a unique identifier to the object
 > #if UNITY_EDITOR
 >     private void Update() {
 >         if (Application.IsPlaying(gameObject)) return;
 >         if (string.IsNullOrEmpty(gameObject.scene.path)) return;
 >
 >         SerializedObject serializedObject = new SerializedObject(this);
 >         SerializedProperty property = serializedObject.FindProperty("uniqueIdentifier");
 >           
 >         if (string.IsNullOrEmpty(property.stringValue) || !IsUnique(property.stringValue))
 >         {
 >             property.stringValue = System.Guid.NewGuid().ToString();
 >             serializedObject.ApplyModifiedProperties();
 >         }
 >
 >         globalLookup[property.stringValue] = this;
 >     }
 > #endif
 >
 >     //Collects all saveable components of this object
 >     public JToken CaptureAsJtoken()
 >     {
 >         IDictionary<string, JToken> stateDict = state;
 >         foreach (IJsonSaveable jsonSaveable in GetComponents<IJsonSaveable>())
 >         {             
 >             JToken token = jsonSaveable.CaptureAsJToken();
 >             string component = jsonSaveable.GetType().ToString();
 >             stateDict[jsonSaveable.GetType().ToString()] = token;
 >         }
 >         return state;
 >     }
 >
 >     //Restores all saveable components of this object
 >     public void RestoreFromJToken(JToken s) 
 >     {
 >         JObject state = s.ToObject<JObject>();
 >         IDictionary<string, JToken> stateDict = state;
 >         foreach (IJsonSaveable jsonSaveable in GetComponents<IJsonSaveable>())
 >         {
 >             string component = jsonSaveable.GetType().ToString();
 >             if (stateDict.ContainsKey(component))
 >             {
 >                 jsonSaveable.RestoreFromJToken(stateDict[component]);
 >             }
 >         }
 >     }
 > }
 > ```
 > <br>
 > The <code>JsonSavingSystem</code> class contains the code for saving and loading Scenes and for deleting saveFiles.
 >
 > ```csharp
 > //Loads the last active Scene for example if the player wants to continue a game.
 > public IEnumerator LoadLastScene(string saveFile)
 > {
 >     JObject state = LoadJsonFromFile(saveFile);
 >     IDictionary<string, JToken> stateDict = state; 
 >     int buildIndex = SceneManager.GetActiveScene().buildIndex;
 >     if (stateDict.ContainsKey("lastSceneBuildIndex"))
 >     {
 >         buildIndex = (int)stateDict["lastSceneBuildIndex"];
 >     }
 >     yield return SceneManager.LoadSceneAsync(buildIndex);
 >     RestoreFromToken(state);
 > }
 >
 > //Loads a given savefile
 > public void Load(string saveFile)
 > {
 >     print("Loading from " + GetPathFromSaveFile(saveFile));
 >     RestoreFromToken(LoadJsonFromFile(saveFile));
 > }
 >
 >//Saves the state of the current scene to the savefile
 > public void Save(string saveFile)
 > {
 >     print("Saving to " + GetPathFromSaveFile(saveFile));
 >     JObject state = LoadJsonFromFile(saveFile);
 >     SaveFileAsJSon(saveFile, state);
 > }
 >
 > //Loads the json data from a file
 > private JObject LoadJsonFromFile(string saveFile)
 > {
 >     string path = GetPathFromSaveFile(saveFile);
 >     print("Loading from " + path);
 >     if (!File.Exists(path))
 >     {
 >         return new JObject();
 >     }
 >     using (var textReader = File.OpenText(path))
 >     {
 >         using (var reader = new JsonTextReader(textReader))
 >         {
 >             reader.FloatParseHandling = FloatParseHandling.Double;
 >             return JObject.Load(reader);
 >         }
 >     }
 > }
 >
 > //Saves the current state to a given savefile
 > private void SaveFileAsJSon(string saveFile, JObject state)
 > {
 >     string path = GetPathFromSaveFile(saveFile);
 >     print("Saving to " + path);
 >     using (var textWriter = File.CreateText(path))
 >     {
 >         using (var writer = new JsonTextWriter(textWriter))
 >         {
 >             writer.Formatting = Formatting.Indented;
 >             state.WriteTo(writer);
 >         }
 >     }
 > }
 >
 > //Deletes the given savefile
 > public void Delete(string saveFile)
 > {
 >     print("Deleting from " + GetPathFromSaveFile(saveFile));
 >     File.Delete(GetPathFromSaveFile(saveFile));
 > }
 >
 > //Collects all saveable objects in a dictionary and sets the lastSceneBuildIndex to the current scene
 > private void CaptureAsToken(JObject state)
 > {
 >     IDictionary<string, JToken> stateDict = state;
 >     foreach (JsonSaveableEntity saveable in FindObjectsOfType<JsonSaveableEntity>())
 >     {
 >         stateDict[saveable.GetUniqueIdentifier()] = saveable.CaptureAsJtoken();
 >     }
 >     stateDict["lastSceneBuildIndex"] = SceneManager.GetActiveScene().buildIndex;
 > }
 >
 > //Restores the state of all the saveable components 
 > private void RestoreFromToken(JObject state)
 > {
 >     IDictionary<string, JToken> stateDict = state;
 >     foreach (JsonSaveableEntity savable in FindObjectsOfType<JsonSaveableEntity>())
 >     {
 >         string id = savable.GetUniqueIdentifier();
 >         if (stateDict.ContainsKey(id))
 >         {
 >             savable.RestoreFromJToken(stateDict[id]);
 >         }
 >     }
 > }
 > ```
 > <br>
 > This is an example how the Saving of the Health of Players and Enemies works. The <code>_healthPoints</code> value is saved using <code>CaptureAsJToken()</code> and loaded using <code>RestoreFromJToken()</code>. After loading the state of the Characters is also updated using <code>UpdateState()</code>.
 >
 > ```csharp
 > public class Health : MonoBehaviour, IJsonSaveable
 > {
 >     private LazyValue<float> _healthPoints; //lazyvalue ensures that variable is initialized before use
 >     
 >     //Converts the healthPoints value to a JToken and returns it to be saved
 >     public JToken CaptureAsJToken()
 >     {
 >         return JToken.FromObject(_healthPoints.value);
 >     }
 >     
 >     //Restores the healthPoints from the given JToken and updates the state
 >     public void RestoreFromJToken(JToken state)
 >     {
 >         float val = state.ToObject<float>();
 >         _healthPoints.value = val;
 >         UpdateState();
 >     }
 >
 >     //Updates the state of the object having the health script on it
 >     private void UpdateState()
 >     {
 >         if (!_wasDeadLastFrame && IsDead())
 >         {
 >             _animator.SetTrigger(DieTrigger);
 >             _actionScheduler.CancelCurrentAction();
 >         }
 >         if (_wasDeadLastFrame && !IsDead())
 >         {
 >             _animator.Rebind();
 >         }
 >         _wasDeadLastFrame = IsDead();
 > }
 > ```
 >
 > </details>
</details>

<details>
  <summary>Scene Management</summary>
 <br>
 
 > <div align="center"> 
 > Portals are used for the transition between levels, through which the players can pass. As a transition, a white screen is displayed to provide enough time for the new scene to load, and then that scene is displayed. The players have set spawn points and are then spawned at that point and the corresponding level is loaded.
 > <img src="https://user-images.githubusercontent.com/104200268/227891326-1d00fcc3-2789-4860-9cef-499e59f94d5b.gif" width="80%" height="auto">
 > </div>
  <br>

 > <details> 
 >  <summary>Code Snippets</summary>
 >  <br>
 > After the player enters a portal the transition to the next scene is started.
 >
 > ```csharp
 > private void OnTriggerEnter(Collider other)
 > {
 >     if (other.CompareTag("Player"))
 >     {
 >         StartCoroutine(TransitionToScene());
 >     }
 > }
 > ```
 >
 > To transition to a new scene the playerController is disabled and the scene is faded out. Next the state of the current scene is saved, the next scene is loaded. Then the portal of the new scene where the player enters is loaded and the player is updated. The transition ends with saving the new scene, fading in and enabling player controls.
 >
 > ```csharp
 > private IEnumerator TransitionToScene()
 > {
 >     if (sceneToLoadIndex < 0)
 >     {
 >         Debug.LogError("Scene to load not set.");
 >         yield break; 
 >     }
 >           
 >     DontDestroyOnLoad(gameObject);
 >          
 >     Fader fader = FindObjectOfType<Fader>();
 >     SavingWrapper savingWrapper = FindObjectOfType<SavingWrapper>();
 >
 >     PlayerController playerController = GameObject.FindWithTag("Player").GetComponent<PlayerController>();
 >     playerController.enabled = false;
 >         
 >     yield return fader.FadeOut(fadeOutTime);
 >           
 >     savingWrapper.Save();
 >           
 >     yield return SceneManager.LoadSceneAsync(sceneToLoadIndex);
 >     PlayerController newPlayerController = GameObject.FindWithTag("Player").GetComponent<PlayerController>();
 >     newPlayerController.enabled = false;
 >           
 >     savingWrapper.Load();
 > 
 >     Portal otherPortal = GetOtherPortal();
 >     UpdatePlayer(otherPortal);
 >
 >     savingWrapper.Save();
 >           
 >     yield return new WaitForSeconds(fadeWaitTime);
 >           
 >     fader.FadeIn(fadeInTime);
 >           
 >     newPlayerController.enabled = true;
 >           
 >     Destroy(gameObject);
 > }
 >
 > //Updates the players position/rotation based on the new portal
 > private void UpdatePlayer(Portal otherPortal)
 > {
 >     GameObject player = GameObject.FindWithTag("Player");
 >     player.GetComponent<NavMeshAgent>().enabled = false;
 >     player.GetComponent<NavMeshAgent>().Warp(otherPortal.spawnPoint.position);
 >     player.transform.rotation = otherPortal.spawnPoint.rotation;
 >     player.GetComponent<NavMeshAgent>().enabled = true;
 > }
 > ```
 >
 > To fade in and out between scenes coroutines are use as displayed in the following code of the Fader.cs class.
 >
 > ```csharp 
 > public class Fader : MonoBehaviour
 > {
 >     private CanvasGroup _canvasGroup;
 >     private Coroutine currentActiveFade = null;
 > 
 >     private void Awake()
 >     {
 >         _canvasGroup = GetComponent<CanvasGroup>();
 >     }
 >
 >     public Coroutine FadeOut(float time)
 >     {
 >         return Fade(time, 1f);
 >     }
 >
 >     public Coroutine FadeIn(float time)
 >     {
 >         return Fade(time, 0);
 >     }
 >
 >     //Fades in or out depending on the alpha value
 >     public Coroutine Fade(float time, float alphaTarget)
 >     {
 >         if (currentActiveFade != null)
 >         {
 >             StopCoroutine(currentActiveFade);
 >         }
 >         currentActiveFade = StartCoroutine(FadeRoutine(time,alphaTarget));
 >         return currentActiveFade;
 >     }
 >     
 >     //Fades out immediately by setting the alpha of the canvasGroup to 1
 >     public void FadeOutImmediate()
 >     {
 >         _canvasGroup.alpha = 1;
 >     }
 >
 >     //Slowly increses/decreases the alpha value of the canvas until the intended alpha value is reached
 >     private IEnumerator FadeRoutine(float time, float alphaTarget)
 >     {
 >         while (!Mathf.Approximately(_canvasGroup.alpha,alphaTarget))
 >         {
 >             _canvasGroup.alpha = Mathf.MoveTowards(_canvasGroup.alpha,alphaTarget, Time.unscaledDeltaTime / time);
 >             yield return null; //wait for 1 frame
 >         }
 >     }
 > }
 > ```
 > <br>
 > </details>
   

</details> 
 
<details>
  <summary>Chests</summary>
  <br>
 
 > <div align="center"> 
 > Chests, as the name suggests, are objects placed in the world that contain items and work as follows. When the players hold the mouse cursor over a chest, the mouse cursor turns into a yellow square. When the players click on a chest, they automatically move into range of the chest, if they are not already in that range from where they can open it.
 > <br>
 > <img src="https://user-images.githubusercontent.com/104200268/227770156-dcc77aea-e740-4666-8390-46ec6a41f624.gif" width="80%" height="auto">
 > </div>
 > <br>
 > <div align="center"> 
 > Once the players are within range, the chest window displayed below opens. The window consists of a mathematical question, an answer field where the players can enter their answer, and a confirmation button. If the answer is correct, the chest opens and a pickup for an item is spawned.  
 > <img src="https://user-images.githubusercontent.com/104200268/227773074-8da5f304-e6e1-4149-80c5-539b9f4ffaaf.png" width="70%" height="auto">
 > </div>
 > <br>
 > <div align="center"> 
 > There are three different types of chests: easy chests, which are wooden and can be opened by solving easy math problems or even trick questions; medium chests, which are golden and can be opened by solving medium math problems; and difficult chests, which are purple and have a golden frame and can be opened by solving difficult math problems.
 > <br>
 > <img src="https://user-images.githubusercontent.com/104200268/227770154-8badb528-65da-446a-9569-44b6c27e9f2d.png" width="60%" height="auto">
 > </div>
 > <br>
 > <div align="center"> 
 > The chests are implemented using scriptable objects, where the developer can configure various options. This includes the respective math problem, a chest prefab depending on the difficulty, a chest protector being the fairy with the clues, a voice output for opening the chest, a level, and a drop library containing the loot that is spawned when the chest is opened.
 > <br>
 > <img src="https://user-images.githubusercontent.com/104200268/227963447-784f63a2-dc0a-4b69-b179-5859e7be0717.png" width="70%" height="auto">
 > </div>
 > <br>
 > <div align="center"> 
 > The math problems are also implemented using scriptable objects consisting of the difficulty, a question, a solution, and a list of hints.
 > <br>
 > <img src="https://user-images.githubusercontent.com/104200268/227963440-7fca7c13-5cd7-4499-abdd-c4c1eb7a5585.png" width="70%" height="auto">
 > </div> 
 <br>
</details>

<details>
  <summary>Shops</summary>
   <br>
   
   > <div align="center"> 
   >   Shops subtly teach math by motivating the players to buy and sell items at different prices and with or without discounts. A shop is indicated in the game by an NPC called a shopkeeper. The shop window shown below opens when clicking on a shopkeeper.
   >  <br>
   >  <img src="https://user-images.githubusercontent.com/104200268/227770460-569c4c95-b963-4cb7-a131-89b8d7e1130e.png" width="70%" height="auto">
   > </div> 
   > <br>
   > <div align="center"> 
   >  It contains various items available for purchase at the current player level, the quantity available for each, the price, and the number that will be added to the shopping list. The players can also switch between buying and selling and filter the items. If they have enough money to buy the corresponding items the items will be added to the players' inventory. 
   >  It should be noted that the transaction is completed only when there is enough space in the inventory and that the stackable items are stacked and not placed in separate places. If the players do not have enough money, the total amount will be displayed in red and the [Kaufen] button will be disabled. 
   >  <br>
   > <img src="https://user-images.githubusercontent.com/104200268/227770519-99289146-2117-4316-bfc8-f4d785567e80.gif" width="90%" height="auto">
   > <img src="https://user-images.githubusercontent.com/104200268/227770826-a3e598af-7dfa-428b-95e4-d6a2278be8af.gif" width="40%" height="auto">
   > </div> 
   > <br>
   > <div align="center"> 
   > There exist different types of shops for example, an armor shop sells different armor items. Some of these shops can also be seen in the image below, where a weapons shop can be seen on the left and an armor shop on the right.
   > <br>
   > <img src="https://user-images.githubusercontent.com/104200268/227770464-ebbb5689-2909-4237-acb7-b239e64786f8.png" width="70%" height="auto">
   > </div> 
   > <br>
   > <div align="center"> 
   > There are various configuration options for shops: the name of the shop, the stock is set by adding items to the stock list and configuring them. Therefore, the initial stock of an item and the level at which the item is sold in the shop can be set. This is used to replenish the shop when a player reaches a new level. Also, the default discount for an item and the sell percentage at which the item can be sold back to the shop can be set. Furthermore, a default selling percentage can be set for the whole shop, which is the percentage of money that the players will receive less for each item that they sell in that shop. Also the maximum discount that players can get in this shop if they maximize the Charisma trait, can be set.
   > <br>
   > <img src="https://user-images.githubusercontent.com/104200268/227975579-137436f0-f745-41a3-8981-af81d934cb19.PNG" width="70%" height="auto">
   > </div>
   <br>
</details>

<details>
  <summary>Item Upgrades</summary>
   <br>
   
   > <div align="center"> 
   > Mathematical content is also integrated into the game through item upgrades. Players can increase a stat corresponding to the item they are upgrading by assigning numbers and signs to different slots to form an equation that gets as close as possible to the maximum number, without exceeding it. This should motivate players to practice mental arithmetic and provides them with the opportunity to optimize their equations each time they collect a new number or sign.
   > <br>
   > <img src="https://user-images.githubusercontent.com/104200268/227770235-918c6946-e085-44bb-8934-d9b8539eb122.gif" width="100%" height="auto">
   > </div>
   > <br>
   > <div align="center"> 
   > Players can move numbers between different items to maximize their stats. The reached value is automatically updated and added to the respective stat. The numbers and signs can be changed at any time to optimize the stat of the item. Only simple operations like addition, subtraction, multiplication, and division are currently supported.
   > <br>
   > <img src="https://user-images.githubusercontent.com/104200268/227773157-4fd39c2a-9f3e-492e-a889-8a4d9cde515f.png" width="50%" height="auto">
   > </div>
   <br>
</details>

<details>
 <summary>Quests</summary>
  <br>
 
  > <div align="center"> 
  > The game features various levels, each focused on a different topic such as percentage calculations, and includes quests that present real-world problems related to the topic. The quests are designed to engage players emotionally by creating an attachment to NPC characters and motivating them to solve mathematical problems to help those characters.
  > The game also includes a quest window displaying active and completed quests, along with their goals and rewards.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227773129-757250c6-f349-4574-a258-8c4c31d723f8.png" width="80%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  > Quests are implemented using scriptable objects that contain objectives, descriptions, and conditions for completion.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227784059-d7468f50-ab60-453d-9dc0-a67f2a4eeebe.PNG" width="70%" height="auto">
  > </div>
  <br> 
 </details>

<details>
  <summary>NPCs</summary>
    <br>
  
  > <div align="center"> 
  > Non-playable characters (NPCs) play a crucial role in a game's story, gameplay, and immersion. There are two types of NPCs: static NPCs and those with dialogs or quests for players. 
  > <img src="https://user-images.githubusercontent.com/104200268/228180590-fa9d8973-d424-455f-aba7-bfbc68b266ae.png" width="80%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  > Static NPCs help make the game world feel more lively, while those with quests or dialogs allow players to interact with them and advance the game's story.  
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/228180616-3b94ff96-29eb-4d8c-ac92-5ff912173a2f.png" width="80%" height="auto">
  > </div>
  > <br>
  > <div align="center">     
  > To implement NPCs, an NPC Controller is used, which contains a list of NPCActions. Each NPCAction includes a description, position in the game world, time for the action, speed, dialog, and list of animation states. The NPC begins in the first action and moves at the set speed to the next action's position when the specified time has elapsed or when a dialog trigger changes the action. 
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/228182600-d797f8b2-2c40-41ab-a73c-17a17bbceab7.PNG" width="70%" height="auto">
  > </div>
  > <br>
  > <div align="center">
  > The use of dialogue triggers provides a high level of control over the NPC's behavior, allowing for multiple actions and dialogues for a single NPC to enhance the game's realism. Also The NPCs gan give quests, complete quest or give the players items.
  > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227784080-f1cc0818-f074-486c-a6da-b61cf8b560dc.PNG" width="70%" height="auto">
  > </div>
 <br>

</details>

<details>
  <summary>Combat</summary>
 
   ![Circle_Auf_Boden](https://user-images.githubusercontent.com/104200268/227770296-7393e827-009d-40d3-8bf2-66c58208fe2a.png)
   
   ![Combat02 (1)](https://user-images.githubusercontent.com/104200268/227770300-7b7ad007-3772-4824-a9cb-df7fcbc2a674.png)
   
   ![ezgif com-optimize](https://user-images.githubusercontent.com/104200268/227770574-cb417695-9541-4a4f-8e6f-ce76981e2da6.gif)
   
   ![enemies](https://user-images.githubusercontent.com/104200268/227770721-d5af6a25-117b-4bcf-bbc9-f14638d5cdc3.PNG)
   
   ![Actionbar (1)](https://user-images.githubusercontent.com/104200268/227773065-0ac0cdaf-2a90-47f8-b20a-23169dcc175b.png)

   ![image24](https://user-images.githubusercontent.com/104200268/227770600-8bd23f67-29e6-4a71-b5c4-b9e46901845b.gif)
  
   ![abilityso](https://user-images.githubusercontent.com/104200268/227782438-9990bba2-73d9-488f-89f5-8ca20afa2ae3.PNG)

   ![enemieconfig](https://user-images.githubusercontent.com/104200268/227782446-ce732ad7-9e89-4f33-bd9d-aa1a6d338b1c.PNG)

   ![droptableso](https://user-images.githubusercontent.com/104200268/227782459-acca4fc9-8328-49c5-8588-ef98f6702e5a.PNG)

</details>

<details>
  <summary>Tutorial</summary>
  <br>
  
  > <div align="center"> 
  > The tutorial introduces various mechanics and features to players in a linear manner. It is implemented using an NPC that explains each feature to the players in a dialog and verifies their understanding through checkpoints. 
 > The tutorial in a game starts with the players interacting with an NPC, who explains the movement and camera controls, basic combat, and HUD. The players must then open a chest, collect an item, and equip it to fight an enemy blocking the way to the next tutorial level. To reach the second level, the players must collect items and pass through a portal, which is explained to them.
  > <img src="https://user-images.githubusercontent.com/104200268/227770307-db398f6f-c979-40eb-82f8-4371b3911c14.png" width="90%" height="auto">
  > </div>
  > <br>
  > <div align="center"> 
  >  In the second part of the game tutorial, players are introduced to abilities and the action bar, followed by a combat sequence where they can test their new abilities. An item dropped by an enemy is used to explain the players' stats, and a chest is opened to show how items are enhanced by bonus stats. Quests are then introduced, where players must collect diamonds from enemies to deepen their understanding of combat mechanics and quests. Completing the quest levels up the player, and trait points are explained. Shops are then introduced, followed by a lesson on how to pause and save the game.
 > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227770308-6e6f8038-4a5b-4b0e-a55b-abe1af29667d.png" width="90%" height="auto">
  > </div>
  > <br>
 
</details>

<details>
  <summary>Level</summary>
 <br>
  
  > <div align="center"> 
  >  The first level of the game, includes a main quest line where players help a farmer chase dwarves away from his farm. To complete the quest, players must defeat enemies in the forest and ruins, talk to the dwarves, and retrieve ingredients to bake apple pie for them. There are also enemies to battle, chests hidden throughout the level that provide items to make combat easier, and shops where players can buy items to get stronger.
 > <br>
  > <img src="https://user-images.githubusercontent.com/104200268/227773147-16f01469-d92c-4dd5-acf4-150a542f906f.png" width="90%" height="auto">
  > </div>
  > <br>

</details>

<details>
  <summary>Items, Inventory & Equipment</summary>
   
   ![Gladiature](https://user-images.githubusercontent.com/104200268/227773632-13ac5757-80d4-482c-8c00-0a187c97fb62.png)

   ![Voll_Bag](https://user-images.githubusercontent.com/104200268/227773165-9d35752c-2f08-4d92-ab82-c4e7d3b60c9c.png)

   ![Inventar_ZuoftSchunGmocht](https://user-images.githubusercontent.com/104200268/227770376-1bd74a0c-e1eb-49fa-aa4f-ba115ed9c0a5.png)

   ![pickups_mit_Untertitel02 (1)](https://user-images.githubusercontent.com/104200268/227773612-9354560d-2631-44d9-bac0-9722b049a7f2.PNG)

   ![math so](https://user-images.githubusercontent.com/104200268/227782490-362ea03f-2107-456b-b195-65b74c05f1ae.PNG)

   ![bowso](https://user-images.githubusercontent.com/104200268/227783402-ae62c1aa-3ba2-4de1-a588-ec69baa010b7.PNG)

   ![helmetso](https://user-images.githubusercontent.com/104200268/227783412-d0e094c0-55b8-4aec-aee2-605aee1c5a4d.PNG)

</details>

<details>
  <summary>Stats & Traits</summary>
  
   ![Stats](https://user-images.githubusercontent.com/104200268/227770405-c5de455d-2b22-4b6a-9718-c5bfed2134e6.png)
   
   ![Stats02](https://user-images.githubusercontent.com/104200268/227770407-1ae44eb7-fcd5-489c-94f2-1a1e2b7dbf7c.png)
  
</details>

<details>
  <summary>Menu & HUD</summary>
  The game can be paused with the [P] key, which freezes time and opens a pause menu where players can save the game. 
   ![image21](https://user-images.githubusercontent.com/104200268/227770525-ef541b4f-d53b-4120-807c-01e16119342c.png)

   ![Main_Menu](https://user-images.githubusercontent.com/104200268/227770545-a1086e54-4a32-4f67-aca6-2fe967083310.png)

   ![PauseMenue02](https://user-images.githubusercontent.com/104200268/227770529-10d03e56-53cc-4d44-85d2-3c4264bc70d0.png)
  
</details>

<details>
  <summary>Progression</summary>

   ![Progression](https://user-images.githubusercontent.com/104200268/227770766-03aae77e-b416-47e4-b5fd-298adc3d674b.PNG)

   ![progressionenemy](https://user-images.githubusercontent.com/104200268/227770767-931b36e0-f552-4b84-81bb-308809898956.PNG)

   ![progressionPlayer](https://user-images.githubusercontent.com/104200268/227770769-d5deefb6-f553-4ed1-b972-cc427b201126.PNG)

</details>
 
 <details>
  <summary>Thesis</summary>
 <br>
  
  > <div align="center"> 
  >  If you are interested in obtaining more information, you can download the final presentation and the bachelor's thesis using the links provided below. These resources contain valuable insights and details about the project.
  > <br>
  > <br>
  >
  > [Presentation.pdf](https://github.com/MarsonerLaura/KingdomOfMath/files/11094274/BA.Prasentation.pptx.pdf)
  > <br>
  >
  > [Thesis.pdf](https://github.com/MarsonerLaura/KingdomOfMath/files/11094238/Thesis.pdf)
  > <br>
  > <br>
  > Abstract
  > <br>
  > Serious games have shown promise as a tool to enhance the learning experience by generating higher intrinsic motivation than traditional learning methods. In this paper, a serious game called Kingdom of Math is developed that aims to teach mathematics to secondary school students using proven design principles. To this end, essential terms and concepts are described, and related work is analyzed. The requirements for such a serious game are outlined, and the approach and design decisions made are discussed and implemented. A user study is conducted to evaluate the developed game, and the results are presented and discussed. In addition, possible improvements and enhancements for this project in the future are suggested.
  > </div>
  > <br>
> 
   

  


</details>
 
</p>
